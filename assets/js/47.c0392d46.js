(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{379:function(v,_,t){"use strict";t.r(_);var l=t(0),a=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("堆（Heap）和栈（Stack）是计算机内存管理中的两个重要概念。它们在内存分配、管理方式、生命周期和用途上有明显的区别。")]),v._v(" "),_("h2",{attrs:{id:"栈-stack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[v._v("#")]),v._v(" 栈（Stack）")]),v._v(" "),_("ol",[_("li",[v._v("内存分配和管理：\n"),_("ul",[_("li",[v._v("栈内存是由编译器自动管理。分配和释放都是由编译器在函数调用时自动进行。")]),v._v(" "),_("li",[v._v("栈是一种后进先出（LIFO，Last In First Out）结构。")])])]),v._v(" "),_("li",[v._v("分配方式：\n"),_("ul",[_("li",[v._v("栈内存以连续块的方式分配。当一个函数被调用时，它的局部变量、参数和返回地址等信息会压入栈中，当函数返回时，这些数据会被弹出栈")])])]),v._v(" "),_("li",[v._v("生命周期：\n"),_("ul",[_("li",[v._v("栈上的数据的生命周期与所属函数的生命周期一致，当函数调用结束时，栈上的数据会自动销毁")])])]),v._v(" "),_("li",[v._v("访问速度：\n"),_("ul",[_("li",[v._v("栈内存的访问速度非常快，因为栈指针的移动速度很快，且栈内存通常位于高速缓存中")])])]),v._v(" "),_("li",[v._v("主要用途：\n"),_("ul",[_("li",[v._v("用于存储局部变量、函数函数以及返回地址")])])]),v._v(" "),_("li",[v._v("内存大小限制：\n"),_("ul",[_("li",[v._v("栈内存大小取决于操作系统和编译器的设置，如果分配的栈内存超过系统配置的栈的大小，可能会导致栈溢出（Stack Overflow）")])])])]),v._v(" "),_("h2",{attrs:{id:"堆-heap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[v._v("#")]),v._v(" 堆（Heap）")]),v._v(" "),_("ol",[_("li",[v._v("内存分配和管理：\n"),_("ul",[_("li",[v._v("堆内存是由程序员管理。分配和释放内存需要由程序员显示调用内存分配函数（如malloc、free在C语言中，new、delete在C++中，或者Go语言中的new和make）。")])])]),v._v(" "),_("li",[v._v("分配方式：\n"),_("ul",[_("li",[v._v("堆内存以动态的方式分配，可以在程序运行时任意分配和释放内存。堆内存块的大小和位置不一定连续")])])]),v._v(" "),_("li",[v._v("生命周期：\n"),_("ul",[_("li",[v._v("堆上数据的生命周期由程序员控制，可以在任何时候分配和释放。数据在堆上可以存在知道显示释放，或者知道程序结束。")])])]),v._v(" "),_("li",[v._v("访问速度：\n"),_("ul",[_("li",[v._v("堆内存的访问速度比较慢，因为需要进行动态内存管理，可能涉及复杂的内存分配和释放操作")])])]),v._v(" "),_("li",[v._v("主要用途：\n"),_("ul",[_("li",[v._v("用于存储需要在多个函数间共享或需要在函数返回后继续存在的数据")])])]),v._v(" "),_("li",[v._v("内存大小限制：\n"),_("ul",[_("li",[v._v("堆内存的大小通常较大，但分配过多内存可能会导致内存不足（Out of Memory）。")])])])]),v._v(" "),_("h2",{attrs:{id:"两者对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两者对比"}},[v._v("#")]),v._v(" 两者对比")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("特性")]),v._v(" "),_("th",[v._v("栈（Stack）")]),v._v(" "),_("th",[v._v("堆（Heap）")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("管理方式")]),v._v(" "),_("td",[v._v("由编译器自动管理")]),v._v(" "),_("td",[v._v("由程序员手动管理")])]),v._v(" "),_("tr",[_("td",[v._v("分配方式")]),v._v(" "),_("td",[v._v("连续分配，后进先出（LIFO）")]),v._v(" "),_("td",[v._v("动态分配，大小和位置不连续")])]),v._v(" "),_("tr",[_("td",[v._v("生命周期")]),v._v(" "),_("td",[v._v("随函数调用结束而自动销毁")]),v._v(" "),_("td",[v._v("由程序员控制，直到显式释放或程序结束")])]),v._v(" "),_("tr",[_("td",[v._v("访问速度")]),v._v(" "),_("td",[v._v("快，直接通过栈指针进行访问")]),v._v(" "),_("td",[v._v("慢，涉及动态内存管理操作")])]),v._v(" "),_("tr",[_("td",[v._v("用途")]),v._v(" "),_("td",[v._v("局部变量、函数参数、返回地址")]),v._v(" "),_("td",[v._v("需要在多个函数间共享或在函数返回后继续存在的数据")])]),v._v(" "),_("tr",[_("td",[v._v("内存大小限制")]),v._v(" "),_("td",[v._v("通常较小，可能会导致栈溢出")]),v._v(" "),_("td",[v._v("通常较大，但分配过多可能导致内存不足")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);