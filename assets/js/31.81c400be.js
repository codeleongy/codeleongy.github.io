(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{363:function(e,t,a){"use strict";a.r(t);var _=a(0),s=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1、pod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、pod"}},[e._v("#")]),e._v(" 1、Pod")]),e._v(" "),t("p",[e._v("Pod是K8s中最小的部署单元，一个Pod可以包含一个或多个容器，这些容器共享网络和存储资源。通常，一个Pod会包含一个应用程序的一个实例。多个容器在一个Pod中运行时，它们共享相同的网络命名空间和存储卷，这使得它们可以通过localhost进行通信，并且更容易共享文件。")]),e._v(" "),t("h2",{attrs:{id:"_2、node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、node"}},[e._v("#")]),e._v(" 2、Node")]),e._v(" "),t("p",[e._v("Node是K8s集群中的一个工作节点，可以是虚拟机或物理机。每个Node上运行以下关键组件：")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("Kubelet")]),e._v("：负责管理Pod的生命周期，确保容器按照期望状态运行。")]),e._v(" "),t("li",[t("em",[e._v("Kube Proxy")]),e._v("：负责维护网络规则，实现集群内的服务发现和负载均衡。")]),e._v(" "),t("li",[t("em",[e._v("Container Runtime")]),e._v("：如Docker或containerd，用于实际运行容器。")])]),e._v(" "),t("h2",{attrs:{id:"_3、namespace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、namespace"}},[e._v("#")]),e._v(" 3、Namespace")]),e._v(" "),t("p",[e._v("Namespace是K8s中的一个虚拟集群，用于在一个物理集群内划分多个逻辑区域。它们通常用于不同的项目、团队或环境（如开发、测试、生产）。Namespace提供了资源隔离和访问控制的机制，确保不同团队或项目之间的资源不会互相干扰。")]),e._v(" "),t("h2",{attrs:{id:"_4、deployment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、deployment"}},[e._v("#")]),e._v(" 4、Deployment")]),e._v(" "),t("p",[e._v("Deployment是用于声明和管理Pod副本的K8s资源。它定义了Pod的期望状态，包括运行的副本数、更新策略等。Deployment通过ReplicaSet确保指定数量的Pod副本始终在集群中运行，并且支持滚动更新和回滚功能。")]),e._v(" "),t("h2",{attrs:{id:"_5、statefulset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、statefulset"}},[e._v("#")]),e._v(" 5、StatefulSet")]),e._v(" "),t("p",[e._v("StatefulSet是K8s中用于管理有状态应用的资源，特别适用于需要持久化存储和有序部署的场景。与Deployment不同，StatefulSet提供了以下特性：")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("稳定的网络标识")]),e._v("：每个Pod都有一个唯一且稳定的网络标识（hostname）。")]),e._v(" "),t("li",[t("em",[e._v("稳定的持久存储")]),e._v("：每个Pod都有一个唯一且稳定的持久存储（PersistentVolume），不会因为Pod的删除和重建而丢失数据。")]),e._v(" "),t("li",[t("em",[e._v("有序部署和扩展")]),e._v("：Pod按照顺序进行部署、扩展和删除操作。\nStatefulSet常用于需要保持状态的分布式系统，如数据库、分布式文件系统等。")])]),e._v(" "),t("h2",{attrs:{id:"_6、service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、service"}},[e._v("#")]),e._v(" 6、Service")]),e._v(" "),t("p",[e._v("Service是K8s中定义的一种资源，用于将一组Pod暴露为一个稳定的网络服务。Service提供了负载均衡和服务发现的功能，即使Pod实例发生变化，Service的访问地址也不会改变。常见的Service类型包括ClusterIP、NodePort和LoadBalancer。")]),e._v(" "),t("h2",{attrs:{id:"_7、configmap和secret"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、configmap和secret"}},[e._v("#")]),e._v(" 7、ConfigMap和Secret")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("ConfigMap")]),e._v("：用于在Pod中存储非机密配置数据。ConfigMap将配置信息与容器镜像分离，使得应用程序配置更加灵活和可管理。")]),e._v(" "),t("li",[t("em",[e._v("Secret")]),e._v("：用于存储敏感数据，如密码、OAuth令牌和SSH密钥。Secret对数据进行编码，并提供安全的存储和访问机制。")])]),e._v(" "),t("h2",{attrs:{id:"_8、volume"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、volume"}},[e._v("#")]),e._v(" 8、Volume")]),e._v(" "),t("p",[e._v("Volume是K8s中用于存储数据的抽象，可以挂载到Pod中的一个或多个容器上。Volume的生命周期与Pod相同，但具体的存储实现可以是持久化存储（如NFS、Ceph）或临时存储（如emptyDir）。")]),e._v(" "),t("h2",{attrs:{id:"_9、ingress"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9、ingress"}},[e._v("#")]),e._v(" 9、Ingress")]),e._v(" "),t("p",[e._v("Ingress是用于暴露HTTP和HTTPS路由到集群外部的资源。它定义了从集群外部到服务的路径规则，并支持SSL终止、虚拟主机等高级功能。Ingress Controller是实现这些规则的组件，常见的有nginx Ingress Controller、Traefik等。")]),e._v(" "),t("h2",{attrs:{id:"_10、探针-probe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10、探针-probe"}},[e._v("#")]),e._v(" 10、探针（Probe）")]),e._v(" "),t("p",[e._v("探针是K8s用来检查容器运行状况的机制，主要有三种类型：")]),e._v(" "),t("ul",[t("li",[e._v("存活探针（Liveness Probe）：用于检测容器是否处于健康状态。如果探测失败，K8s会重新启动容器。常见的使用场景是检测死锁等情况。")]),e._v(" "),t("li",[e._v("就绪探针（Readiness Probe）：用于检测容器是否已经准备好接受流量。如果探测失败，容器将从Service的负载均衡器中移除。常见的使用场景是确保应用在启动时完全加载并准备好处理请求。")]),e._v(" "),t("li",[e._v("启动探针（Startup Probe）：用于检测应用程序是否已经启动完成。它只在容器启动时执行，如果探测成功，其他探针将开始执行。常见的使用场景是针对启动时间较长的应用。")])]),e._v(" "),t("p",[e._v("探针可以通过以下方式进行配置：")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("HTTP GET")]),e._v("：向指定的端点发送HTTP GET请求，并根据响应状态码判断探测结果。")]),e._v(" "),t("li",[t("em",[e._v("TCP Socket")]),e._v("：尝试打开与容器的TCP连接，如果连接成功，探测就认为成功。")]),e._v(" "),t("li",[t("em",[e._v("命令执行")]),e._v("：在容器内执行指定命令，根据命令的退出状态判断探测结果。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);